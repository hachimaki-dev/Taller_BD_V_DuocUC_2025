-- =============================================================================
-- ENTREGABLE 1: MODELO RELACIONAL ORACLE (COMENTARIOS ANIDADOS)
-- =============================================================================

-- 1. LIMPIEZA DE ENTORNO
-- Borramos la tabla si existe para evitar errores de re-ejecución.
BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE comentarios CASCADE CONSTRAINTS';
EXCEPTION
    WHEN OTHERS THEN NULL; -- Si no existe, ignoramos el error
END;
/

-- 2. CREACIÓN DE LA TABLA (DDL)
-- Utilizamos una tabla auto-referenciada (Adjacency List Model).
CREATE TABLE comentarios (
    comentario_id   NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    post_id         NUMBER NOT NULL,       -- ID del post al que pertenece el hilo
    usuario_id      NUMBER NOT NULL,       -- ID del autor
    parent_id       NUMBER,                -- Puntero al comentario padre (NULL si es raíz)
    contenido       VARCHAR2(1000),
    fecha_creacion  TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    -- Restricción de integridad referencial (Auto-referencia)
    CONSTRAINT fk_comentario_padre FOREIGN KEY (parent_id)
        REFERENCES comentarios (comentario_id)
        ON DELETE CASCADE -- Si borran el padre, se borran los hijos (cascada)
);

-- Índices para mejorar performance en los JOINs recursivos
CREATE INDEX idx_parent_id ON comentarios(parent_id);
CREATE INDEX idx_post_id ON comentarios(post_id);

-- 3. INSERCIÓN DE DATOS (DML) - SIMULACIÓN DE 5 NIVELES DE PROFUNDIDAD

-- 3. GENERACIÓN DE DATOS MASIVOS (PL/SQL)
-- Generamos una jerarquía de aprox. 12 niveles con miles de comentarios.
DECLARE
    TYPE NumList IS TABLE OF NUMBER;
    v_padres NumList;
    v_nuevos_padres NumList := NumList();
    v_post_id NUMBER := 101;
    v_counter NUMBER := 0;
    v_id_generado NUMBER;
BEGIN
    -- Limpiamos datos previos
    DELETE FROM comentarios;
    
    -- Nivel 1: 5 Comentarios Raíz
    SELECT 0 BULK COLLECT INTO v_padres FROM DUAL WHERE 1=0; -- Inicializar vacío
    
    FOR i IN 1..5 LOOP
        INSERT INTO comentarios (post_id, usuario_id, parent_id, contenido)
        VALUES (v_post_id, 100+i, NULL, 'Comentario Raíz ' || i)
        RETURNING comentario_id INTO v_id_generado;
        
        v_padres.EXTEND;
        v_padres(v_padres.LAST) := v_id_generado;
    END LOOP;

    -- Niveles 2 al 12: Crecimiento exponencial controlado
    -- Limitamos el ancho para no explotar la cuota de disco en entornos pequeños (aprox 5k-10k registros)
    FOR nivel IN 2..12 LOOP
        v_nuevos_padres := NumList(); -- Reiniciar lista de padres para el siguiente nivel
        
        IF v_padres.COUNT > 0 THEN
            FOR i IN 1..v_padres.COUNT LOOP
                -- Cada comentario tiene entre 0 y 2 respuestas (promedio 1.5 hijos)
                -- Esto evita que el árbol crezca demasiado rápido (5 -> 10 -> 20...)
                FOR h IN 1..ROUND(DBMS_RANDOM.VALUE(0, 2)) LOOP
                    INSERT INTO comentarios (post_id, usuario_id, parent_id, contenido)
                    VALUES (v_post_id, 200+nivel, v_padres(i), 'Nivel ' || nivel || ' - Respuesta ' || h)
                    RETURNING comentario_id INTO v_id_generado;
                    
                    v_nuevos_padres.EXTEND;
                    v_nuevos_padres(v_nuevos_padres.LAST) := v_id_generado;
                END LOOP;
            END LOOP;
            
            -- Avanzamos al siguiente nivel
            v_padres := v_nuevos_padres;
        END IF;
    END LOOP;
    
    COMMIT;
    DBMS_OUTPUT.PUT_LINE('Datos generados exitosamente.');
END;
/

-- 4. CONSULTAS (QUERIES)

-- A) CONSULTA RECURSIVA PARA OBTENER TODO EL ÁRBOL (CONNECT BY)
-- Esta es la forma clásica en Oracle para recorrer jerarquías.
SELECT 
    LEVEL,
    LPAD(' ', (LEVEL-1)*4) || contenido AS arbol_visual,
    comentario_id,
    parent_id,
    usuario_id,
    SYS_CONNECT_BY_PATH(comentario_id, '/') AS path_completo
FROM 
    comentarios
START WITH 
    parent_id IS NULL -- Empezamos por los nodos raíz
CONNECT BY 
    PRIOR comentario_id = parent_id -- La relación es ID Padre -> ID Hijo
ORDER SIBLINGS BY 
    fecha_creacion ASC;

-- B) OBTENER SOLO LAS RESPUESTAS (SUB-ÁRBOL) DE UN COMENTARIO ESPECÍFICO
-- Ejemplo: Obtener todo lo que cuelga del comentario ID 2
SELECT 
    LEVEL,
    contenido,
    usuario_id
FROM 
    comentarios
START WITH 
    comentario_id = 2
CONNECT BY 
    PRIOR comentario_id = parent_id;

-- C) RENDERIZADO VISUAL ORDENADO POR NIVEL (ALTERNATIVA CON CTE RECURSIVA - ANSI SQL)
-- Útil si se quiere portar a otros motores SQL, aunque Oracle soporta CONNECT BY nativo.
WITH arbol_comentarios (comentario_id, parent_id, contenido, nivel, ruta) AS (
    -- Caso base: Comentarios raíz
    SELECT 
        comentario_id, 
        parent_id, 
        contenido, 
        1 AS nivel, 
        TO_CHAR(comentario_id) AS ruta
    FROM comentarios 
    WHERE parent_id IS NULL
    
    UNION ALL
    
    -- Caso recursivo: Hijos
    SELECT 
        c.comentario_id, 
        c.parent_id, 
        c.contenido, 
        ac.nivel + 1, 
        ac.ruta || '/' || c.comentario_id
    FROM comentarios c
    JOIN arbol_comentarios ac ON c.parent_id = ac.comentario_id
)
SELECT 
    nivel,
    LPAD('-', (nivel-1)*2, '-') || contenido AS contenido_identado,
    ruta
FROM arbol_comentarios
ORDER BY ruta;
